# 彭中华 ｜ Part 1 | 模块二
拉钩前端训练营 part 1 的模块2 作业
## 简答题
### 第一题：请说出下列最终的执行结果，并解释为什么。
```
var a = []
for(var i = 0; i < 10; i++){
    a[i] = function(){
        console.log(i)
    }
}
a[6]()
```
答：10
i为全局变量。每次循环后i值加1，且向数组a里存入一个函数。循环结束后，i等于10，执行```a[6]()```，打印出全局变量i为10。
### 第二题：请说出下列最终的执行结果，并解释为什么。
```
var tmp = 123;
if(true){
    console.log(tmp)
    let tmp
}
```
答：执行结果会报错。
let 声明的变量，要先申明后调用。如果调用前未声明，就会报错。
在这个题目里，var 申明的 tmp 是全局变量，if 语句里的 tmp 是局部变量。执行打印tmp时，按照作用域链，先从当前作用域内查找，找不到时，去作用域外查找，一直找到全局作用域，直到找到为止。当前作用域内 tmp 是局部变量，并且是什么前调用，所有报错了。
### 第三题：结合ES6新语法，用最简单的方式找出数组中的最小值。
```
var arr = [12,34,32,89,4]
```
答：
```
var min = Math.min(...arr)
console.log(min)
```
### 第四题：请详细说明 var,let,const 三种声明变量的方式之间的具体差别。
答：
1、var 声明的变量，以函数作用域为区分，内层函数作用域可以访问外层函数作用域内或全局作用域内的变量，反之不可以。
2、let，const申明的变量，以块作用域{}为区分，内层块作用域可以访问外层块作用域的变量，反之不可以。
3、var 申明的变量存在变量提升，即申明语句会被提升到代码顶部，调用语句可以在声明之前或者之后；let，const申明的变量，不存在变量提升，必须先申明后调用。
4、let 申明的变量，申明和赋值可以分开写，即先申明，后赋值。const 申明和赋值必须同时执行。
### 第五题：请说出下列代码最终输出的结果，并解释为什么。
```
var a = 10;
var obj = {
  a: 20,
  fn(){
    setTimeout(()=>{
      console.log(this.a)
    })
  }       
}
obj.fn()
```
答：20
函数里的this指向函数被调用时的调用对象。执行obj.fn函数时，this指向fn函数的调用对象obj，this.a就等于20。
### 第六题：简述 Symbol 类型的用途。
答：Symbol 类型的值具有唯一性。
1、为对象添加一个独一无二的属性名
2、为对象添加私有属性
### 第七题: 说说什么是浅拷贝，什么是深拷贝？
答：浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；深拷贝：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。
### 第八题：请简述 TypeScript 与 JavaScript 之间的关系。
答：TS是基于JS之上的语言，是JS的超集。包含JS、ES6和类型系统，最终编译为JS，TS解决了JS自由类型系统的问题。
### 第九题：请谈谈你所认为的 TypeScript 优缺点。
答：
优点：
1、可以在编译阶段就发现大部分错误
2、增加了代码的可读性和可维护性
3、增强了编辑器的功能，包括代码补全，接口提示、重构等
缺点：
1、有一些学习成本，需要学习新概念(接口、泛型、枚举、类)
2、会增加一部分开发成本，需要定义一些类型和接口等
3、可能和一些库的结合不是很完美
### 第十题：描述引用计数的工作原理和优缺点。
答：
工作原理：在内部通过一个引用计数器标记变量的引用次数。当一个变量的引用关系有变动时，就修改引用次数，比如，当变量被引用(调用)，引用计数器就加1，程序执行后，变量如果没有被引用的地方了(比如没有在闭包里引用)，其引用次数就变为0，就会被回收。
优点：
1、程序执行过程中可以立即清除垃圾
2、减少程序的暂停
缺点：
1、对循环引用的对象不会回收
2、垃圾回收的时间开销相当大些
### 第十一题：描述标记整理算法的工作流程。
答：第一步先标记，和标记清楚算法的标记是一样的。
然后，整理不连续的碎片空间，使之成为连续的空间，
最后再清除垃圾空间。
### 第十二题：描述V8中新生代存储区垃圾回收的流程。
答：新生代存储器分为:From 空间和To 空间，大小相等。使用复制算法和标记整理算法。先把变量放到From空间，触发GC垃圾回收时，复制From空间的所有内容到To空间，然后整理空间，把From空间清空释放。

复制过程中可能出现晋升，即在一个GC过程后没有被清理的对象会存储到老生代存储区。

而且To空间的利用率不能超过25%。
### 第十三题：描述增量标记算法在何时使用及工作原理。
答：
垃圾回收时，需要将程序暂停下来。老生代存储区的垃圾回收时，程序暂停时间相对较长。为了降低老生代区垃圾回收较长的停顿时间，采用增量标记算法，将标记过程标记为一个个的子标记过程，同时将垃圾回收和JS程序执行交替进行，直到标记阶段完成。这样每次回收垃圾时，停顿时间就短了。
